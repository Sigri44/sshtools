#!/bin/bash

# Check and install required packages
check_install_packages() {
    local required_packages=("$@")
    local missing_packages=()
    local package_manager=""
    local install_command=""

    # Detect package manager
    if command -v apt-get >/dev/null 2>&1; then
        package_manager="apt"
        install_command="apt-get install -y"
    elif command -v dnf >/dev/null 2>&1; then
        package_manager="dnf"
        install_command="dnf install -y"
    elif command -v yum >/dev/null 2>&1; then
        package_manager="yum"
        install_command="yum install -y"
    elif command -v apk >/dev/null 2>&1; then
        package_manager="apk"
        install_command="apk add"
    else
        echo -e "${red}No supported package manager found (apt, dnf, yum, or apk)${reset}"
        return 1
    fi

    # Package name mappings for different distributions
    declare -A package_names
    case $package_manager in
        "apt")
            package_names=(
                ["source-highlight"]="source-highlight"
                ["python3"]="python3"
                ["python3-psutil"]="python3-psutil"
                ["python3-docker"]="python3-docker"
                ["python3-requests"]="python3-requests"
                ["python3-distro"]="python3-distro"
                ["python3-netifaces"]="python3-netifaces"
                ["smartmontools"]="smartmontools"
                ["fio"]="fio"
                ["bc"]="bc"
                ["curl"]="curl"
                ["dmidecode"]="dmidecode"
                ["ethtool"]="ethtool"
                ["net-tools"]="net-tools"
                ["whois"]="whois"
            )
            ;;
        "dnf"|"yum")
            package_names=(
                ["source-highlight"]="source-highlight"
                ["python3"]="python3"
                ["python3-psutil"]="python3-psutil"
                ["python3-docker"]="python3-docker"
                ["python3-requests"]="python3-requests"
                ["python3-distro"]="python3-distro"
                ["python3-netifaces"]="python3-netifaces"
                ["smartmontools"]="smartmontools"
                ["fio"]="fio"
                ["bc"]="bc"
                ["curl"]="curl"
                ["dmidecode"]="dmidecode"
                ["ethtool"]="ethtool"
                ["net-tools"]="net-tools"
                ["whois"]="whois"
            )
            ;;
        "apk")
            package_names=(
                ["source-highlight"]="source-highlight"
                ["python3"]="python3"
                ["py3-psutil"]="py3-psutil"
                ["py3-docker"]="py3-docker"
                ["py3-requests"]="py3-requests"
                ["py3-distro"]="py3-distro"
                ["py3-netifaces"]="py3-netifaces"
                ["smartmontools"]="smartmontools"
                ["fio"]="fio"
                ["bc"]="bc"
                ["curl"]="curl"
                ["dmidecode"]="dmidecode"
                ["ethtool"]="ethtool"
                ["net-tools"]="net-tools"
                ["whois"]="whois"
            )
            ;;
    esac

    # Check for missing packages
    for pkg in "${required_packages[@]}"; do
        local package_name="${package_names[$pkg]}"
        if [ -z "$package_name" ]; then
            package_name="$pkg"
        fi

        case $package_manager in
            "apt")
                if ! dpkg -l | grep -q "^ii.*$package_name"; then
                    missing_packages+=("$package_name")
                fi
                ;;
            "dnf"|"yum")
                if ! rpm -q "$package_name" >/dev/null 2>&1; then
                    missing_packages+=("$package_name")
                fi
                ;;
            "apk")
                if ! apk info -e "$package_name" >/dev/null 2>&1; then
                    missing_packages+=("$package_name")
                fi
                ;;
        esac
    done

    # Install missing packages if any
    if [ ${#missing_packages[@]} -gt 0 ]; then
        echo -e "\n${yellow}The following packages are required:${reset}"
        echo -e "${On_Black}${bold}─────────────────────────────────────────${reset}"
        for pkg in "${missing_packages[@]}"; do
            echo -e "  ${cyan}•${reset} $pkg"
        done
        echo -e "${On_Black}${bold}─────────────────────────────────────────${reset}\n"
        
        read -p "$(echo -e "${yellow}Do you want to install these packages? [Y/n]${reset} ")" -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]] || [[ -z $REPLY ]]; then
            echo -e "\n${yellow}Installing packages...${reset}"
            
            if [ "$package_manager" = "apt" ]; then
                sudo apt-get update
            fi
            
            if sudo $install_command "${missing_packages[@]}"; then
                echo -e "\n${green}✓ Successfully installed all required packages${reset}"
                return 0
            else
                echo -e "\n${red}✗ Failed to install some packages${reset}"
                return 1
            fi
        else
            echo -e "\n${yellow}⚠ Package installation skipped${reset}"
            return 1
        fi
    fi
    return 0
}

# Function to check required packages for a specific command
check_requirements() {
    local command_name="$1"
    local required_packages=()

    case $command_name in
        "benchmark")
            required_packages=("fio" "bc" "curl" "dmidecode" "ethtool" "net-tools")
            ;;
        "checksec")
            required_packages=("net-tools" "whois" "dmidecode" "curl")
            ;;
        "webshare")
            required_packages=("python3")
            ;;
        "logwatch")
            required_packages=("bc")
            ;;
    esac

    if [ ${#required_packages[@]} -gt 0 ]; then
        if ! check_install_packages "${required_packages[@]}"; then
            echo -e "${red}Unable to proceed: missing required packages${reset}"
            return 1
        fi
    fi
    return 0
}

. /etc/profile
. ~/.bashrc

# Color variables:
export black='\033[0;30m'
export red="\e[0;31m"
export green="\e[0;32m"
export yellow="\e[0;33m"
export blue="\e[0;34m"
export purple="\e[0;35m"
export grey="\e[0;37m"
export reset="\e[m"
export bold="\e[1m"
# Background
export On_Black='\033[40m'       # Black
export On_Red='\033[41m'         # Red
export On_Green='\033[42m'       # Green
export On_Yellow='\033[43m'      # Yellow
export On_Blue='\033[44m'        # Blue
export On_Purple='\033[45m'      # Purple
export On_Cyan='\033[46m'        # Cyan
export On_White='\033[47m'       # White

# Configuration for colored less output
export LESS='-R'
export LESSOPEN="| /usr/share/source-highlight/src-hilite-lesspipe.sh %s"
export LESS_TERMCAP_mb=$'\E[1;31m'     # begin blink
export LESS_TERMCAP_md=$'\E[1;36m'     # begin bold
export LESS_TERMCAP_me=$'\E[0m'        # reset bold/blink
export LESS_TERMCAP_so=$'\E[01;44;33m' # begin reverse video
export LESS_TERMCAP_se=$'\E[0m'        # reset reverse video
export LESS_TERMCAP_us=$'\E[1;32m'     # begin underline
export LESS_TERMCAP_ue=$'\E[0m'        # reset underline

# Enhanced log colorization without dependencies
colorize_log() {
    # Common patterns
    sed -E \
    # Headers and separators
    -e "s/^==> (.*) <==/$(printf '\033[1;35;40m')==> \1 <==$(printf '\033[0m')/g" \
    -e "s/^([-=_]{3,}.*[-=_]{3,})/$(printf '\033[0;35m')\1$(printf '\033[0m')/g" \
    -e "s/([|].*[|])/$(printf '\033[0;35m')\1$(printf '\033[0m')/g" \
    
    # Log levels
    -e "s/\[(DEBUG|TRACE)\]/$(printf '\033[0;32m')[\1]$(printf '\033[0m')/gi" \
    -e "s/\[(INFO|NOTICE)\]/$(printf '\033[0;36m')[\1]$(printf '\033[0m')/gi" \
    -e "s/\[(WARN(ING)?)\]/$(printf '\033[1;33m')[\1]$(printf '\033[0m')/gi" \
    -e "s/\[(ERROR|FATAL|CRIT(ICAL)?)\]/$(printf '\033[1;31m')[\1]$(printf '\033[0m')/gi" \
    -e "s/\[(UFW BLOCK|BLOCK(ED)?)\]/$(printf '\033[1;37;41m')[\1]$(printf '\033[0m')/gi" \
    
    # Status and actions
    -e "s/\b(error|fail(ed|ure)?|crit(ical)?|fatal)\b/$(printf '\033[1;31m')&$(printf '\033[0m')/gi" \
    -e "s/\b(warn(ing)?)\b/$(printf '\033[1;33m')&$(printf '\033[0m')/gi" \
    -e "s/\b(success(ful)?|succeed|completed)\b/$(printf '\033[1;32m')&$(printf '\033[0m')/gi" \
    -e "s/\b(start(ed|ing)?|run(ning)?|done)\b/$(printf '\033[0;32m')&$(printf '\033[0m')/gi" \
    -e "s/\b(stop(ped|ping)?|end(ed|ing)?|exit(ed|ing)?)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi" \
    -e "s/\b(kill(ed|ing)?|terminat(e|ed|ing)|abort(ed)?)\b/$(printf '\033[1;31m')&$(printf '\033[0m')/gi" \
    -e "s/\b(started|initialized|loaded|configured|enabled)\b/$(printf '\033[0;32m')&$(printf '\033[0m')/gi" \
    -e "s/\b(stopped|disabled|unloaded|deconfigured|terminated)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi" \
    
    # Security related
    -e "s/\b(auth|login|user|root|admin|sudo)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    -e "s/\b(session opened|authenticated|granted)\b/$(printf '\033[0;32m')&$(printf '\033[0m')/gi" \
    -e "s/\b(session closed|disconnected|logged out)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi" \
    -e "s/\b(invalid|failed|denied|reject(ed)?)\b/$(printf '\033[0;31m')&$(printf '\033[0m')/gi" \
    -e "s/\b(attack|hack|exploit|malicious|threat|intrusion|breach|vulnerability)\b/$(printf '\033[1;37;41m')&$(printf '\033[0m')/gi" \
    -e "s/\b(unauthorized|forbidden|blocked|blacklisted|whitelisted)\b/$(printf '\033[1;31m')&$(printf '\033[0m')/gi" \
    -e "s/\b(permission|access|authorization|authentication)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    
    # System operations
    -e "s/\b(backup|restore|save|load|archive|snapshot)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    -e "s/\b(install(ed|ing)?|updat(e|ed|ing)|upgrade|config|setup|deploy(ed|ing)?)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    -e "s/\b(systemd|kernel|linux|ubuntu|debian|centos|fedora|redhat)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    -e "s/\b(read|write|execute|modify|create|delete|chmod|chown)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi" \
    -e "s/\b(mount|umount|format|partition|filesystem)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    
    # Container and virtualization
    -e "s/\b(docker|container|pod|volume|kubernetes|k8s|swarm|compose)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    -e "s/\b(vm|virtual|hypervisor|qemu|kvm|xen|vbox)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    
    # Network related
    -e "s/\b(tcp|udp|icmp|http[s]?|ssh|ftp|dns|smtp|pop3|imap|ldap|ssl|tls)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    -e "s/\b(port|socket|connection|packet|protocol)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    -e "s/\b(IN|OUT|SRC|DST|PROTO|SPT|DPT|TTL|ID|WINDOW|MAC|LEN|SEQ|ACK|FLAGS)\b=/$(printf '\033[0;36m')\1=$(printf '\033[0m')/g" \
    -e "s/\b([0-9]{1,3}\.){3}[0-9]{1,3}\b/$(printf '\033[1;34m')&$(printf '\033[0m')/g" \
    -e "s/\b([0-9a-f]{2}:){5}[0-9a-f]{2}\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    -e "s/\b(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS|TRACE|CONNECT)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/g" \
    
    # Database related
    -e "s/\b(nginx|apache|mysql|postgresql|mongodb|redis|elasticsearch)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    -e "s/\b(query|transaction|commit|rollback|index|table|database)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    
    # Performance and metrics
    -e "s/\b(cpu|memory|disk|network|io|bandwidth|latency|throughput)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi" \
    -e "s/\b([0-9]+(\.[0-9]+)?(ms|[TGMK]B|[TGMK]b|s|%|Hz|Mhz|Ghz))\b/$(printf '\033[0;33m')&$(printf '\033[0m')/g" \
    -e "s/\b(timeout|expired|overflow|underflow|exceeded|limit)\b/$(printf '\033[0;31m')&$(printf '\033[0m')/gi" \
    
    # Programming and debugging
    -e "s/\b(0x[0-9a-fA-F]+)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/g" \
    -e "s/\b(true|false|null|undefined|nil)\b/$(printf '\033[0;36m')&$(printf '\033[0m')/gi" \
    -e "s/\b(exception|stacktrace|traceback|debug|breakpoint)\b/$(printf '\033[0;31m')&$(printf '\033[0m')/gi" \
    -e "s/\b(function|method|class|object|variable|constant)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    
    # Time and dates
    -e "s/\b([0-9]{4}-[0-9]{2}-[0-9]{2})[T ]([0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?([+-][0-9]{2}:?[0-9]{2})?)\b/$(printf '\033[0;34m')\1 \2$(printf '\033[0m')/g" \
    -e "s/^([A-Za-z]{3}\s+[0-9]+\s+[0-9:]+)/$(printf '\033[0;34m')\1$(printf '\033[0m')/g" \
    
    # URLs and paths
    -e "s/(https?:\/\/[^\s]+)/$(printf '\033[4;34m')&$(printf '\033[0m')/g" \
    -e "s/\b(\/[^\s]+)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/g" \
    
    # Process and system
    -e "s/\b(pid|process|thread|signal|fork|exec)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    -e "s/\b(daemon|service|init|systemd|cron|at)\b/$(printf '\033[0;35m')&$(printf '\033[0m')/gi" \
    
    # Hardware related
    -e "s/\b(cpu|gpu|ram|disk|nic|usb|pci|sata|nvme)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi" \
    -e "s/\b(temperature|fan|power|voltage|current)\b/$(printf '\033[0;33m')&$(printf '\033[0m')/gi"
}

# Enhanced less and tail commands with automatic colorization
less_with_color() {
    local file="$1"
    
    # Check if the file is a log file (based on extension or path)
    if [[ "$file" =~ \.(log|txt)$ ]] || [[ "$file" =~ ^/var/log/ ]] || [[ "$file" == "syslog" ]]; then
        # If it's a compressed file
        if [[ "$file" =~ \.gz$ ]]; then
            zcat "$file" | colorize_log | less -R
        else
            cat "$file" | colorize_log | less -R
        fi
    else
        # Use source-highlight for code files
        less "$@"
    fi
}

tail_with_color() {
    # If -f option is present, add colorization
    if [[ "$*" == *"-f"* ]]; then
        tail "$@" | colorize_log
    else
        tail "$@"
    fi
}

# Replace original commands with enhanced versions
alias less='less_with_color'
alias tail='tail_with_color'

# Function to detect distribution
detect_distribution() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        echo "$PRETTY_NAME"
    elif [ -f /etc/redhat-release ]; then
        cat /etc/redhat-release
    elif [ -f /etc/debian_version ]; then
        echo "Debian $(cat /etc/debian_version)"
    elif [ -f /etc/lsb-release ]; then
        . /etc/lsb-release
        echo "$DISTRIB_DESCRIPTION"
    else
        echo "Unknown distribution"
    fi
}

# Function to check for updates
check_updates() {
    if command -v apt-get &> /dev/null; then
        updates=$(apt-get -s upgrade | grep -c "^Inst")
        security_updates=$(apt-get -s upgrade | grep -c "^Inst.*security")
        if [ $updates -eq 0 ]; then
            echo "${green}No updates available${reset}"
        elif [ $updates -le 10 ]; then
            echo "${yellow}$updates updates available${reset}"
        else
            echo "${red}$updates updates available${reset}"
        fi
        if [ $security_updates -gt 0 ]; then
            echo "${red}$security_updates security updates available${reset}"
        fi
    elif command -v yum &> /dev/null; then
        updates=$(yum check-update --quiet 2>/dev/null | grep -v "^$" | wc -l)
        security_updates=$(yum updateinfo list security --quiet 2>/dev/null | grep -v "^$" | wc -l)
        if [ $updates -eq 0 ]; then
            echo "${green}No updates available${reset}"
        elif [ $updates -le 10 ]; then
            echo "${yellow}$updates updates available${reset}"
        else
            echo "${red}$updates updates available${reset}"
        fi
        if [ $security_updates -gt 0 ]; then
            echo "${red}$security_updates security updates available${reset}"
        fi
    else
        echo "${yellow}Unknown package manager${reset}"
    fi
}

# MOTD
# Information gathering
motd() {
    hostname=$(hostname)
    distribution=$(detect_distribution)
    updates_info=$(check_updates)
    userconnected=$(who | grep -c pts)
    usernames=$(who | grep pts | awk '{print $1}' | paste -sd " " -)
    proc=$(nproc --all)
    proc_120=$(($proc*120/100))
    memtotal=$(cat /proc/meminfo | grep MemTotal | awk '{print $2}')
    memavailable=$(cat /proc/meminfo | grep MemAvailable | awk '{print $2}')
    memcached=$(cat /proc/meminfo | grep "^Cached:" | awk '{print $2}')
    membuffers=$(cat /proc/meminfo | grep Buffers | awk '{print $2}')
    memused=$((memtotal - memavailable))
    memusedpercent=$((memused * 100 / memtotal))
    if [ $memusedpercent -lt 90 ]; then
        ramcolor=$green
    elif [ $memusedpercent -lt 96 ]; then
        ramcolor=$yellow
    else
        ramcolor=$red
    fi
    # Get swap information
    swaptotal=$(cat /proc/meminfo | grep SwapTotal | awk '{print $2}')
    swapfree=$(cat /proc/meminfo | grep SwapFree | awk '{print $2}')
    if [ $swaptotal -gt 0 ]; then
        swapused=$(($swaptotal-$swapfree))
        swapusedpercent=$(($swapused*100/$swaptotal))
        if [ $swapusedpercent -lt 50 ]; then
            swapcolor=$green
        elif [ $swapusedpercent -lt 80 ]; then
            swapcolor=$yellow
        else
            swapcolor=$red
        fi
    fi
    uptime=$(uptime -p 2> /dev/null)
    uptime_s=$(awk -F '.' '{print $1}' /proc/uptime)
    if [ $uptime_s -lt 86400 ]; then
        uptcolor=$yellow
    else
        uptcolor=$green
    fi
    addrip=$(hostname -I | cut -d " " -f1)
    public_ip=$(curl -s -f --connect-timeout 1 ifconfig.me)
    read one five fifteen rest < /proc/loadavg
    if (( $(echo "$one $proc" | awk '{print ($1 < $2)}') )); then
        onecolor=$green
    elif (( $(echo "$one $proc_120" | awk '{print ($1 < $2)}') )); then
        onecolor=$yellow
    else
        onecolor=$red
    fi
    if (( $(echo "$five $proc" | awk '{print ($1 < $2)}') )); then
        fivecolor=$green
    elif (( $(echo "$five $proc_120" | awk '{print ($1 < $2)}') )); then
        fivecolor=$yellow
    else
        fivecolor=$red
    fi
    if (( $(echo "$fifteen $proc" | awk '{print ($1 < $2)}') )); then
        fifteencolor=$green
    elif (( $(echo "$fifteen $proc_120" | awk '{print ($1 < $2)}') )); then
        fifteencolor=$yellow
    else
        fifteencolor=$red
    fi

    # Function to generate progress bar
    generate_progress_bar() {
        local percent=$1
        local width=20
        local filled=$(($width * $percent / 100))
        local empty=$(($width - $filled))
        printf "["
        printf "%${filled}s" | tr ' ' '='
        printf "%${empty}s" | tr ' ' ' '
        printf "] "
    }

    # Get storage information
    while read -r line; do
        if [[ $line =~ ^/dev/ ]]; then
            mount=$(echo $line | awk '{print $6}')
            size=$(echo $line | awk '{print $2}')
            used=$(echo $line | awk '{print $3}')
            avail=$(echo $line | awk '{print $4}')
            usepercent=$(echo $line | awk '{print $5}' | sed 's/%//')
            
            if [ $usepercent -lt 80 ]; then
                diskcolor=$green
            elif [ $usepercent -lt 90 ]; then
                diskcolor=$yellow
            else
                diskcolor=$red
            fi
            
            # Calculate maximum length for alignment
            mount_padded=$(printf "%-12s" "$mount")
            size_padded=$(printf "%4s" "$size")
            avail_padded=$(printf "%4s" "$avail")
            usepercent_padded=$(printf "%3s" "$usepercent")
            storage_info="$storage_info\n  $mount_padded: ${diskcolor}$(generate_progress_bar $usepercent) ${usepercent_padded}%${reset} (${avail_padded} / ${size_padded})"
        fi
    done < <(df -h | grep -v "tmpfs\|devtmpfs\|snap")

    # Check Docker presence
    if command -v docker &> /dev/null; then
        # Vérifier les droits Docker avec un timeout
        if timeout 2 docker info &>/dev/null; then
            total_containers=$(timeout 2 docker ps -a --format '{{.Status}}' | wc -l)
            healthy_containers=$(timeout 2 docker ps -a --format '{{.Status}}' | grep -c "healthy")
            running_containers=$(timeout 2 docker ps -a --format '{{.Status}}' | grep -c "Up" | grep -v "healthy")
            unhealthy_containers=$(timeout 2 docker ps -a --format '{{.Status}}' | grep -c "unhealthy")
            stopped_containers=$(timeout 2 docker ps -a --format '{{.Status}}' | grep -c "Exited")
            
            docker_info="  Docker : ${blue}Present${reset} → ${blue}${running_containers} running${reset} (${green}${healthy_containers} healthy${reset}, ${red}${unhealthy_containers} unhealthy${reset}) - ${yellow}${stopped_containers} stopped${reset}"
        else
            docker_info="  Docker : ${yellow}Present (no permission)${reset}"
        fi
    fi

    # Display MOTD
    motd_content=$(cat /etc/motd /etc/motd.d/* 2>/dev/null)
    if [ -n "$motd_content" ]; then
        echo -e "\n$motd_content\n  -------------------\n"
    fi
    echo -e "\n  Hostname : ${blue}${bold}$(hostname)$purple${moreinfo}${reset}"
    echo -e "  Distribution : ${bold}$distribution${reset}"
    echo -e "  Updates : $updates_info"
    echo -e "  Connected users : ${bold}$userconnected$purple (${usernames})${reset}"
    printf "\n  Processors : $proc"
    printf "\n"
    printf "  Load CPU : $onecolor$one (1min)$reset / $fivecolor$five (5min)$reset / $fifteencolor$fifteen (15min)$reset"
    printf "\n"
    printf "  IP Address : $public_ip ($addrip)"
    printf "\n"
    printf "  RAM : $(($memused/1024/1024))GB / $(($memtotal/1024/1024))GB ($ramcolor$memusedpercent%% used$reset) - Cache: $(($(($membuffers+$memcached))/1024/1024))GB"
    printf "\n"
    if [ $swaptotal -gt 0 ]; then
        printf "  SWAP : $(($swapfree/1024/1024))GB free / $(($swaptotal/1024/1024))GB ($swapcolor$swapusedpercent%% used$reset)"
    else
        printf "  SWAP : ${yellow}disabled${reset}"
    fi
    printf "\n"
    printf "  Uptime : $uptcolor$uptime$reset"
    printf "\n"
    # Display storage information
    echo -e "$storage_info"
    printf "\n"
    if [ -n "$docker_info" ]; then
        printf "$docker_info"
    else
        printf "  Docker : ${yellow}Absent${reset}"
    fi
    printf "\n"
    printf "\n"
}
export -f motd
motd



# Family help
chelp() {
    echo -e "\nAvailable commands:

    ${bold}System Information:${reset}
    ${bold}motd${reset}               : Display welcome message with system information
    ${bold}benchmark${reset}          : Run comprehensive server performance tests (CPU, RAM, Disk, Network)
    ${bold}checksec${reset}           : Perform security audit and show recommendations
    ${bold}logwatch${reset}           : Watch system logs in real-time with color highlighting

    ${bold}File Management:${reset}
    ${bold}extract${reset}            : Extract any type of archive (tar, zip, rar, etc.)
    ${bold}compress${reset}           : Compress files/directories (tar.gz, tar.bz2, zip)
    ${bold}findfile${reset}           : Search for files with color highlighting
    ${bold}tree${reset}               : Display directory structure in tree format
    ${bold}diskspace${reset}          : Analyze disk usage and show largest files/directories
    ${bold}webshare${reset}           : Start a web file sharing server with upload/download support
    ${bold}webshare_cleanup${reset}   : Clean up webshare server and firewall rules

    ${bold}Editor Commands:${reset}
    ${bold}p / hp${reset}             : Show / hide current path in prompt
    ${bold}vic${reset}                : Vim with local vimrc /tmp/.vimrc_remote

    ${bold}System Commands:${reset}
    ${bold}start/stop/restart${reset} : Service management
    ${bold}status${reset}             : Service status
    ${bold}enable/disable${reset}     : Enable/disable services
    ${bold}reload${reset}             : Reload service configuration
    ${bold}oomanalyser${reset}        : Execute script to analyze out of memory events

    ${bold}Network Commands:${reset}
    ${bold}ips${reset}                : Show all ips informations
    ${bold}ports${reset}              : Show listening ports
    ${bold}myip${reset}               : Show public IP
    ${bold}localip${reset}            : Show local IP

    ${bold}Monitoring Commands:${reset}
    ${bold}topcpu${reset}             : Show top 10 CPU processes
    ${bold}topmem${reset}             : Show top 10 memory processes
    ${bold}df${reset}                 : Show disk usage (human readable)
    ${bold}du${reset}                 : Show directory usage (human readable)
    ${bold}free${reset}               : Show memory usage (human readable)

    ${bold}Security Commands:${reset}
    ${bold}chmod${reset}              : Change file permissions (verbose)
    ${bold}chown${reset}              : Change file owner (verbose)
    ${bold}chgrp${reset}              : Change file group (verbose)

    ${bold}Git Commands:${reset}
    ${bold}gs${reset}                 : Git status
    ${bold}ga${reset}                 : Git add
    ${bold}gc${reset}                 : Git commit
    ${bold}gp${reset}                 : Git push
    ${bold}gl${reset}                 : Git pull
    ${bold}gd${reset}                 : Git diff

    ${bold}Docker Commands:${reset}
    ${bold}dps${reset}                : List running containers
    ${bold}dls${reset}                : List all containers
    ${bold}dim${reset}                : List images
    ${bold}dlog${reset}               : Show container logs
    ${bold}dstop${reset}              : Stop container
    ${bold}drm${reset}                : Remove container
    ${bold}drmi${reset}               : Remove image
    "
}
export -f chelp


# Increase process priority with nice and ionice
if [ "$EUID" -eq 0 ]; then
    renice -n -20 -p $$ >/dev/null
    ionice -c 2 -n 0 -p $$ >/dev/null
fi

suroot() {
    user=$(whoami)
    sudo -E su -c "bash --rcfile /home/$user/.bashrc_remote"
}
export -f suroot
# Custom prompt
case "$(whoami)" in
    root)
        PS1_USER_COLOR="$red"
        ;;
    l3)
        PS1_USER_COLOR="$purple"
        ;;
    *)
        PS1_USER_COLOR="$green"
        ;;
esac
export PS1_USER_COLOR

export PS1="\[${PS1_USER_COLOR}\]\u\[${grey}\]@\[${blue}\]\h \[${grey}\]>\[${reset}\] "
p() {
    export PS1="\[${PS1_USER_COLOR}\]\u\[${grey}\]@\[${blue}\]\h\[${yellow}\]:\w \[${grey}\]>\[${reset}\] "
}
export -f p

hp() {
    export PS1="\[${PS1_USER_COLOR}\]\u\[${grey}\]@\[${blue}\]\h \[${grey}\]>\[${reset}\] "
}
export -f hp


bind '"\e[A": history-search-backward' # Up arrow to browse commands with similar start
bind '"\e[B": history-search-forward'  # Down arrow to move forward in history

# Vim with custom vimrc
vic() {
    $(which vim) -u /tmp/.vimrc_remote "$@"
}
export -f vic

oomanalyser() {
    local tmpfile=$(mktemp)
    local url="https://raw.githubusercontent.com/LukeShirnia/out-of-memory/3f8bdbc38f8139e228be0085960e190554148af3/oom-investigate.py"
    local hash="1bdae43494d9ab115b565ff76bd0542b260017ad3ee1fd03d8c4cb929649d1ff"
    curl "$url" --output "$tmpfile"
    if [[ "$(sha256sum $tmpfile | awk '{print $1}')" == "$hash" ]]; then
        chmod +x "$tmpfile" 
        "$tmpfile" "$@"
    else
        echo "Hash is not correct, exiting"
    fi
    rm "$tmpfile"
}
export -f oomanalyser

# ls color 
alias ls='ls --color=auto -F'
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias ll='ls -lhF'
alias la='ls -lhA'
alias l='ls -CF'
alias rm='rm -i'
alias rf='rm -rfi'
alias cp='cp -i'
alias mv='mv -i'
alias mkdir='mkdir -p'

# Service management aliases
if command -v systemctl &> /dev/null; then
    alias start='sudo systemctl start'
    alias stop='sudo systemctl stop'
    alias restart='sudo systemctl restart'
    alias status='systemctl status'
    alias enable='sudo systemctl enable'
    alias disable='sudo systemctl disable'
    alias reload='sudo systemctl reload'
elif command -v service &> /dev/null; then
    alias start='sudo service'
    alias stop='sudo service'
    alias restart='sudo service'
    alias status='service'
    alias reload='sudo service'
fi

# Network aliases
alias ports='netstat -tulanp'
alias myip='curl -s ifconfig.me'
alias localip='hostname -I | cut -d" " -f1'

# System monitoring aliases
alias topcpu='ps aux | sort -nrk 3,3 | head -n 10'
alias topmem='ps aux | sort -nrk 4,4 | head -n 10'
alias df='df -h'
alias du='du -h'
alias free='free -h'

# Security aliases
alias chmod='chmod -v'
alias chown='chown -v'
alias chgrp='chgrp -v'

# Git aliases
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'

# Docker aliases
if command -v docker &> /dev/null; then
    alias dps='docker ps'
    alias dls='docker ps -a'
    alias dim='docker images'
    alias dlog='docker logs'
    alias dstop='docker stop'
    alias drm='docker rm'
    alias drmi='docker rmi'
fi

# Custom aliases
alias aptuprd='sudo apt update && sudo apt upgrade -y && sudo apt dist-upgrade -y && sudo apt autoremove -y'
alias ducks='for item in .* *; do [ "$item" != "." ] && [ "$item" != ".." ] && [ -e "$item" ] && sudo du -hsx "$item"; done | sort -rh | head -10'
alias clean_journal_logs='sudo journalctl --vacuum-size=100M'
alias docker_stats='docker run --rm -ti --name=ctop  --volume /var/run/docker.sock:/var/run/docker.sock:ro quay.io/vektorlab/ctop:latest -s cpu'

# Progress bar function
progress_bar() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local completed=$((width * current / total))
    local remaining=$((width - completed))
    
    printf "\rProgress: ["
    printf "%${completed}s" | tr " " "="
    printf "%${remaining}s" | tr " " " "
    printf "] %d%%" $percentage
}

# Memory formatting function
format_memory() {
    local bytes=$1
    if [ $bytes -gt 1073741824 ]; then # 1 GiB
        echo "$(echo "scale=1; $bytes/1073741824" | bc) GiB"
    elif [ $bytes -gt 1048576 ]; then # 1 MiB
        echo "$(echo "scale=1; $bytes/1048576" | bc) MiB"
    elif [ $bytes -gt 1024 ]; then # 1 KiB
        echo "$(echo "scale=1; $bytes/1024" | bc) KiB"
    else
        echo "${bytes} B"
    fi
}

# Server Benchmark Function
benchmark() {
    # Check required packages
    if ! check_requirements "benchmark"; then
        return 1
    fi

    echo -e "\n${blue}🔍 Running Server Performance Tests${reset}\n"

    # CPU Test
    echo -e "${yellow}📊 CPU Performance Test${reset}"
    echo -e "Testing CPU with simple calculation loop...\n"
    
    local start_time=$(date +%s.%N)
    local iterations=500
    for i in $(seq 1 $iterations); do
        echo "scale=500; 4*a(1)" | bc -l >/dev/null 2>&1
        if [ $((i % 10)) -eq 0 ]; then
            progress_bar $i $iterations
        fi
    done
    local end_time=$(date +%s.%N)
    local cpu_time=$(echo "$end_time - $start_time" | bc)
    local cpu_score=$(echo "scale=2; $iterations / $cpu_time" | bc)
    
    echo -e "\n\nCPU Results:"
    echo -e "CPU Score: ${green}$cpu_score ops/s${reset}"
    
    echo -e "\nCPU Info:"
    grep "model name" /proc/cpuinfo | head -1
    echo "CPU Cores: $(nproc)"
    echo -e "Current CPU Load: $(uptime | awk -F'load average:' '{ print $2 }')\n"

    # Memory Test
    echo -e "${yellow}💾 Memory Information${reset}"
    echo "Testing memory read/write speed..."
    
    # Get total memory in MB for test sizing
    local total_mb=$(awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo)
    # Use 25% of total memory for testing, minimum 1GB, maximum 8GB
    local write_mb=$(( total_mb / 4 ))
    if [ $write_mb -lt 1024 ]; then
        write_mb=1024
    elif [ $write_mb -gt 8192 ]; then
        write_mb=8192
    fi
    
    # Test memory write speed with dd
    local write_speed=0
    local read_speed=0
    
    # Create test file first
    dd if=/dev/zero of=/dev/shm/test bs=1M count=$write_mb status=none
    
    # Test write speed (3 iterations)
    local write_total=0
    local read_total=0
    local test_iterations=3
    
    echo "Testing write speed..."
    for i in $(seq 1 $test_iterations); do
        progress_bar $i $test_iterations
        local result=$(dd if=/dev/zero of=/dev/shm/test bs=64k count=$(( write_mb * 16 )) conv=fdatasync 2>&1 | grep copied | awk '{print $(NF-1)}' | sed 's/,/./')
        if [[ $result =~ ^[0-9.]+$ ]]; then
            write_total=$(echo "$write_total + $result" | bc)
        fi
    done
    write_speed=$(echo "scale=1; $write_total / $test_iterations" | bc)
    echo -e "\n"
    
    echo "Testing read speed..."
    for i in $(seq 1 $test_iterations); do
        progress_bar $i $test_iterations
        local result=$(dd if=/dev/shm/test of=/dev/null bs=64k count=$(( write_mb * 16 )) 2>&1 | grep copied | awk '{print $(NF-1)}' | sed 's/,/./')
        if [[ $result =~ ^[0-9.]+$ ]]; then
            read_total=$(echo "$read_total + $result" | bc)
        fi
    done
    read_speed=$(echo "scale=1; $read_total / $test_iterations" | bc)
    echo -e "\n"
    
    # Cleanup
    rm -f /dev/shm/test
    
    # Format speeds for display
    local write_speed_display
    local read_speed_display
    
    if [ -n "$write_speed" ] && [ "$write_speed" != "0" ]; then
        if [ $(echo "$write_speed > 1000" | bc -l) -eq 1 ]; then
            write_speed_display="$(echo "scale=1; $write_speed/1000" | bc) GB/s"
        else
            write_speed_display="$write_speed MB/s"
        fi
    else
        write_speed_display="N/A"
    fi
    
    if [ -n "$read_speed" ] && [ "$read_speed" != "0" ]; then
        if [ $(echo "$read_speed > 1000" | bc -l) -eq 1 ]; then
            read_speed_display="$(echo "scale=1; $read_speed/1000" | bc) GB/s"
        else
            read_speed_display="$read_speed MB/s"
        fi
    else
        read_speed_display="N/A"
    fi
    
    echo -e "\nMemory Results:"
    echo -e "Memory Write Speed: ${green}$write_speed_display${reset}"
    echo -e "Memory Read Speed:  ${green}$read_speed_display${reset}"
    
    echo -e "\nMemory Status:"
    # Get memory info in MB to avoid arithmetic errors
    local total_mb=$(awk '/MemTotal/ {print int($2/1024)}' /proc/meminfo)
    local free_mb=$(awk '/MemFree/ {print int($2/1024)}' /proc/meminfo)
    local available_mb=$(awk '/MemAvailable/ {print int($2/1024)}' /proc/meminfo)
    local buffers_mb=$(awk '/Buffers/ {print int($2/1024)}' /proc/meminfo)
    local cached_mb=$(awk '/^Cached/ {print int($2/1024)}' /proc/meminfo)
    local used_mb=$((total_mb - free_mb - buffers_mb - cached_mb))
    
    # Format memory values in GiB for display with proper precision
    local total_gib=$(echo "scale=1; $total_mb/1024" | bc)
    local used_gib=$(echo "scale=1; $used_mb/1024" | bc)
    local buffers_cached_gib=$(echo "scale=1; ($buffers_mb + $cached_mb)/1024" | bc)
    local available_gib=$(echo "scale=1; $available_mb/1024" | bc)
    
    # Calculate percentages using MB values to avoid floating point errors
    local mem_usage=$(echo "scale=1; ($used_mb * 100) / $total_mb" | bc)
    local mem_buffers_cached=$(echo "scale=1; (($buffers_mb + $cached_mb) * 100) / $total_mb" | bc)
    
    # Ensure we don't display negative values for used memory
    if [ $(echo "$used_gib < 0" | bc) -eq 1 ]; then
        used_gib="0.0"
        mem_usage="0.0"
    fi
    
    # Add proper spacing for single digit values
    if [ $(echo "$total_gib < 10" | bc) -eq 1 ]; then
        total_gib="  $total_gib"
    fi
    if [ $(echo "$used_gib < 10" | bc) -eq 1 ]; then
        used_gib="  $used_gib"
    fi
    if [ $(echo "$buffers_cached_gib < 10" | bc) -eq 1 ]; then
        buffers_cached_gib="  $buffers_cached_gib"
    fi
    if [ $(echo "$available_gib < 10" | bc) -eq 1 ]; then
        available_gib="  $available_gib"
    fi
    
    echo -e "Total Memory:    ${green}${total_gib} GiB${reset}"
    echo -e "Used Memory:     ${green}${used_gib} GiB${reset} (${mem_usage}%)"
    echo -e "Cache/Buffers:   ${green}${buffers_cached_gib} GiB${reset} (${mem_buffers_cached}%)"
    echo -e "Available:       ${green}${available_gib} GiB${reset}"

    # Disk Test
    echo -e "\n${yellow}💿 Disk Performance Test${reset}"
    echo "Testing disk write speed..."
    
    # Try to clear cache if we have sudo rights
    if [ -w "/proc/sys/vm/drop_caches" ]; then
        sync && echo 3 > /proc/sys/vm/drop_caches
    fi
    
    # Create a temporary directory for disk tests
    local test_dir=$(mktemp -d)
    local test_file="$test_dir/test_file"
    
    # Write test with smaller file and multiple iterations for better average
    local write_total=0
    local read_total=0
    local test_iterations=3
    local file_size=512 # MB
    
    echo -e "Running disk write test ($test_iterations iterations)..."
    for i in $(seq 1 $test_iterations); do
        progress_bar $i $test_iterations
        local write_result=$(dd if=/dev/zero of="$test_file" bs=1M count=$file_size conv=fdatasync 2>&1 | grep -o "[0-9.]*" | tail -1)
        write_total=$(echo "$write_total + $write_result" | bc)
    done
    local write_score=$(echo "scale=1; $write_total / $test_iterations" | bc)
    echo -e "\n"
    
    echo "Testing disk read speed..."
    for i in $(seq 1 $test_iterations); do
        progress_bar $i $test_iterations
        local read_result=$(dd if="$test_file" of=/dev/null bs=1M count=$file_size 2>&1 | grep -o "[0-9.]*" | tail -1)
        read_total=$(echo "$read_total + $read_result" | bc)
    done
    local read_score=$(echo "scale=1; $read_total / $test_iterations" | bc)
    echo -e "\n"

    # IOPS Test
    echo "Testing disk IOPS..."
    
    if command -v fio >/dev/null 2>&1; then
        local test_dir=$(mktemp -d)
        local test_file="$test_dir/fio_test"
        
        # Sequential Write IOPS
        echo "Testing sequential write IOPS..."
        local seq_write_iops=$(fio --name=seq_write --filename=$test_file --rw=write --bs=4k --size=1G --numjobs=1 --direct=1 --group_reporting --runtime=10 --time_based --output-format=terse | awk -F';' '{print int($49)}')
        
        # Sequential Read IOPS
        echo "Testing sequential read IOPS..."
        local seq_read_iops=$(fio --name=seq_read --filename=$test_file --rw=read --bs=4k --size=1G --numjobs=1 --direct=1 --group_reporting --runtime=10 --time_based --output-format=terse | awk -F';' '{print int($8)}')
        
        # Random Write IOPS
        echo "Testing random write IOPS..."
        local random_write_iops=$(fio --name=rand_write --filename=$test_file --rw=randwrite --bs=4k --size=1G --numjobs=1 --direct=1 --group_reporting --runtime=10 --time_based --output-format=terse | awk -F';' '{print int($49)}')
        
        # Random Read IOPS
        echo "Testing random read IOPS..."
        local random_read_iops=$(fio --name=rand_read --filename=$test_file --rw=randread --bs=4k --size=1G --numjobs=1 --direct=1 --group_reporting --runtime=10 --time_based --output-format=terse | awk -F';' '{print int($8)}')
        
        # Cleanup
        rm -rf "$test_dir"
        
        echo -e "\nIOPS Results:"
        echo -e "Sequential Write: ${green}${seq_write_iops:-0} IOPS${reset}"
        echo -e "Sequential Read:  ${green}${seq_read_iops:-0} IOPS${reset}"
        echo -e "Random Write:     ${green}${random_write_iops:-0} IOPS${reset}"
        echo -e "Random Read:      ${green}${random_read_iops:-0} IOPS${reset}"
    else
        echo -e "\n${yellow}IOPS test skipped: fio not installed${reset}"
        echo -e "To install fio:"
        echo -e "  - Debian/Ubuntu: ${grey}sudo apt install fio${reset}"
        echo -e "  - RHEL/CentOS:  ${grey}sudo yum install fio${reset}"
        echo -e "  - Alpine:        ${grey}apk add fio${reset}"
        seq_write_iops=0
        seq_read_iops=0
        random_write_iops=0
        random_read_iops=0
    fi

    # Network Test
    echo -e "\n${yellow}🌐 Network Test${reset}"
    echo "Testing network connectivity..."
    local ping_score=$(ping -c 5 8.8.8.8 2>/dev/null | tail -1 | cut -d '/' -f5)
    
    echo "Testing download speed..."
    # Test with larger files for better speed measurement
    local speed_total=0
    local net_iterations=2
    local test_files=(
        "https://speed.hetzner.de/1GB.bin"
        "https://speed.hetzner.de/2GB.bin"
        "https://proof.ovh.net/files/1Gb.dat"
        "https://bouygues.testdebit.info/1G.iso"
    )
    local timeout=30
    
    for i in $(seq 1 $net_iterations); do
        progress_bar $i $net_iterations
        for url in "${test_files[@]}"; do
            local speed=$(curl -s -w "%{speed_download}\n" -o /dev/null "$url" -m $timeout 2>/dev/null | awk '{printf "%.1f", $1/1024/1024}')
            if [ ! -z "$speed" ] && [ "$speed" != "0.0" ]; then
                speed_total=$(echo "$speed_total + $speed" | bc)
                break 2
            fi
        done
    done
    local network_score=$(echo "scale=1; $speed_total / 1" | bc)
    echo -e "\n"
    
    echo -e "\nNetwork Results:"
    echo -e "Latency: ${green}${ping_score:-N/A} ms${reset}"
    echo -e "Speed: ${green}${network_score:-0.0} MB/s${reset}"

    # Hardware Information
    echo -e "\n${blue}🔧 Hardware Information${reset}"
    
    # Check if system is VM or Physical
    echo -e "\n${bold}System Type:${reset}"
    if [ -f /sys/class/dmi/id/product_name ] || [ -f /proc/cpuinfo ]; then
        vm_detect=""
        if grep -qi "VMware" /sys/class/dmi/id/product_name 2>/dev/null || grep -qi "VMware" /proc/cpuinfo 2>/dev/null; then
            vm_detect="VMware Virtual Machine"
        elif grep -qi "VirtualBox" /sys/class/dmi/id/product_name 2>/dev/null || grep -qi "VirtualBox" /proc/cpuinfo 2>/dev/null; then
            vm_detect="VirtualBox Virtual Machine"
        elif grep -qi "KVM" /sys/class/dmi/id/product_name 2>/dev/null || grep -qi "KVM" /proc/cpuinfo 2>/dev/null; then
            vm_detect="KVM Virtual Machine"
        elif grep -qi "Microsoft" /sys/class/dmi/id/product_name 2>/dev/null || grep -qi "Microsoft" /proc/cpuinfo 2>/dev/null; then
            vm_detect="Hyper-V Virtual Machine"
        elif [ -e /proc/xen ]; then
            vm_detect="Xen Virtual Machine"
        elif systemd-detect-virt >/dev/null 2>&1; then
            vm_detect="$(systemd-detect-virt) Virtual Machine"
        else
            vm_detect="Physical Machine"
        fi
        echo -e "Type:      ${green}$vm_detect${reset}"

        # Try to detect hosting provider
        local public_ip=$(curl -s -4 --connect-timeout 1 ifconfig.me)
        if [ ! -z "$public_ip" ]; then
            local hosting_info=""
            if command -v whois >/dev/null 2>&1; then
                hosting_info=$(timeout 1 whois "$public_ip" 2>/dev/null | grep -iE "^(Organization|OrgName|org-name|owner|netname):" | head -n1 | cut -d':' -f2- | sed 's/^ *//')
                if [ ! -z "$hosting_info" ]; then
                    echo -e "Provider:  ${green}$hosting_info${reset}"
                fi
            else
                # Alternative if whois is not available - try to get ASN info from ipinfo.io
                hosting_info=$(curl -s "https://ipinfo.io/$public_ip/org" 2>/dev/null)
                if [ ! -z "$hosting_info" ]; then
                    echo -e "Provider:  ${green}$hosting_info${reset}"
                fi
            fi
        fi

        # Show chassis information for physical machines
        if [ "$vm_detect" = "Physical Machine" ]; then
            if command -v dmidecode >/dev/null 2>&1; then
                local chassis_manufacturer=$(sudo dmidecode -t chassis 2>/dev/null | grep "Manufacturer:" | cut -d: -f2- | sed 's/^ *//')
                local chassis_model=$(sudo dmidecode -t chassis 2>/dev/null | grep "Version:" | cut -d: -f2- | sed 's/^ *//')
                if [ ! -z "$chassis_manufacturer" ] || [ ! -z "$chassis_model" ]; then
                    echo -e "Chassis:   ${green}$chassis_manufacturer $chassis_model${reset}"
                fi
            fi
        fi
    fi
    
    # CPU Information
    echo -e "\n${bold}CPU Details:${reset}"
    if [ -f /proc/cpuinfo ]; then
        local cpu_model=$(grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2- | sed 's/^[ \t]*//')
        local cpu_cores=$(nproc)
        local cpu_freq=$(grep "cpu MHz" /proc/cpuinfo | head -1 | cut -d: -f2- | sed 's/^[ \t]*//'| awk '{printf "%.2f", $1/1000}')
        local cpu_sockets=$(grep "physical id" /proc/cpuinfo | sort -u | wc -l)
        local cores_per_socket=$((cpu_cores / cpu_sockets))

        echo -e "Model:     ${green}$cpu_model${reset}"
        if [ "$cpu_sockets" -gt 1 ]; then
            echo -e "CPUs:      ${green}$cpu_sockets physical CPU(s)${reset}"
            echo -e "Cores:     ${green}$cpu_cores cores total ($cores_per_socket cores per CPU)${reset}"
        else
            echo -e "Cores:     ${green}$cpu_cores cores${reset}"
        fi
        echo -e "Frequency: ${green}${cpu_freq} GHz${reset}"
    fi
    
    # Memory Information
    echo -e "\n${bold}Memory Details:${reset}"
    if [ -f /proc/meminfo ]; then
        local total_mem=$(grep "MemTotal" /proc/meminfo | awk '{printf "%.1f GB", $2/1024/1024}')
        local mem_type=""
        local mem_speed=""
        if command -v dmidecode >/dev/null 2>&1; then
            mem_type=$(sudo dmidecode -t memory 2>/dev/null | grep -m1 "Type:" | cut -d: -f2- | sed 's/^[ \t]*//')
            mem_speed=$(sudo dmidecode -t memory 2>/dev/null | grep -m1 "Speed:" | cut -d: -f2- | sed 's/^[ \t]*//')
            if [ -z "$mem_speed" ] || [[ "$mem_speed" == *"Unknown"* ]]; then
                mem_speed="Not available"
            fi
        fi
        echo -e "Total:     ${green}${total_mem}${reset}"
        if [ ! -z "$mem_type" ]; then
            echo -e "Type:      ${green}${mem_type}${reset}"
        fi
        if [ ! -z "$mem_speed" ]; then
            echo -e "Speed:     ${green}${mem_speed}${reset}"
        fi
    fi
    
    # Disk Information
    echo -e "\n${bold}Disk Details:${reset}"
    if [ "$vm_detect" = "Physical Machine" ]; then
        if command -v lsblk >/dev/null 2>&1; then
            while read -r disk; do
                if echo "$disk" | grep -qE "^[hs]d[a-z]|^nvme[0-9]"; then
                    local diskname=$(echo "$disk" | awk '{print $1}')
                    local disksize=$(echo "$disk" | awk '{print $4}')
                    local diskmodel=$(echo "$disk" | awk '{$1=$2=$3=$4=""; print $0}' | sed 's/^[ \t]*//')
                    
                    echo -e "Device:    ${green}/dev/$diskname ($disksize)${reset}"
                    if [ ! -z "$diskmodel" ]; then
                        echo -e "Model:     ${green}$diskmodel${reset}"
                    fi

                    if command -v smartctl >/dev/null 2>&1; then
                        # Get SMART data
                        local smart_data=$(sudo smartctl -A "/dev/$diskname" 2>/dev/null)
                        if [ $? -eq 0 ]; then
                            # Power on hours
                            local power_on_hours=$(echo "$smart_data" | grep -i "Power_On_Hours\|Power On Hours" | awk '{print $4}' | head -1)
                            if [ ! -z "$power_on_hours" ]; then
                                echo -e "Runtime:   ${green}$power_on_hours hours${reset}"
                            fi

                            # Check if it's an NVMe drive
                            if echo "$smart_data" | grep -q "NVMe Log"; then
                                # NVMe specific data
                                local temp=$(echo "$smart_data" | grep "Temperature:" | awk '{print $2}')
                                local data_read=$(echo "$smart_data" | grep "Data Units Read:" | awk -F'[\\[\\]]' '{print $2}')
                                local data_written=$(echo "$smart_data" | grep "Data Units Written:" | awk -F'[\\[\\]]' '{print $2}')
                                local unsafe_shutdowns=$(echo "$smart_data" | grep "Unsafe Shutdowns:" | awk '{print $3}')
                                local media_errors=$(echo "$smart_data" | grep "Media and Data Integrity Errors:" | awk '{print $6}')
                                local error_entries=$(echo "$smart_data" | grep "Error Information Log Entries:" | awk '{print $5}')

                                [ ! -z "$temp" ] && echo -e "Temp:      ${green}${temp}°C${reset}"
                                [ ! -z "$data_read" ] && echo -e "Read:      ${green}${data_read}${reset}"
                                [ ! -z "$data_written" ] && echo -e "Written:   ${green}${data_written}${reset}"
                                [ ! -z "$unsafe_shutdowns" ] && echo -e "Unsafe Shutdowns: ${green}${unsafe_shutdowns}${reset}"
                                [ ! -z "$media_errors" ] && echo -e "Media Errors: ${green}${media_errors}${reset}"
                                [ ! -z "$error_entries" ] && echo -e "Error Entries: ${green}${error_entries}${reset}"
                            else
                                # Standard SATA/SAS drive data
                                local reallocated=$(echo "$smart_data" | grep "Reallocated_Sector_Ct" | awk '{print $10}')
                                local pending=$(echo "$smart_data" | grep "Current_Pending_Sector" | awk '{print $10}')
                                local offline_uncorrectable=$(echo "$smart_data" | grep "Offline_Uncorrectable" | awk '{print $10}')
                                local temp=$(echo "$smart_data" | grep "Temperature_Celsius" | awk '{print $10}')

                                [ ! -z "$reallocated" ] && [ "$reallocated" != "0" ] && echo -e "Reallocated Sectors: ${red}${reallocated}${reset}"
                                [ ! -z "$pending" ] && [ "$pending" != "0" ] && echo -e "Pending Sectors: ${red}${pending}${reset}"
                                [ ! -z "$offline_uncorrectable" ] && [ "$offline_uncorrectable" != "0" ] && echo -e "Uncorrectable Sectors: ${red}${offline_uncorrectable}${reset}"
                                [ ! -z "$temp" ] && echo -e "Temperature: ${green}${temp}°C${reset}"
                            fi
                        fi
                    fi
                    echo ""
                fi
            done < <(lsblk -dno NAME,SIZE,TYPE,MODEL | grep -v "loop\|sr0\|cd")
        fi
    else
        # Virtual Machine disk info
        if command -v lsblk >/dev/null 2>&1; then
            local total_size=0
            while read -r disk; do
                if echo "$disk" | grep -qE "^[hs]d[a-z]|^nvme[0-9]"; then
                    local diskname=$(echo "$disk" | awk '{print $1}')
                    local disksize=$(echo "$disk" | awk '{print $4}')
                    local disksize_bytes=$(echo "$disk" | awk '{gsub(/G/,"",$4); print int($4 * 1024 * 1024 * 1024)}')
                    total_size=$((total_size + disksize_bytes))
                    local disktype=$(sudo file -s "/dev/$diskname" 2>/dev/null | grep -o "VMware\|VirtualBox\|QEMU\|Hyper-V" || echo "Virtual")
                    echo -e "Device:    ${green}/dev/$diskname ($disksize)${reset}"
                    echo -e "Type:      ${green}$disktype virtual disk${reset}"
                    echo ""
                fi
            done < <(lsblk -dno NAME,SIZE,TYPE,MODEL | grep -v "loop\|sr0\|cd")
            echo -e "Total:     ${green}$(numfmt --to=iec-i --suffix=B --format="%.1f" $total_size)${reset}"
        fi
    fi
    
    # Network Card Information
    echo -e "\n${bold}Network Details:${reset}"
    if command -v ip >/dev/null 2>&1; then
        # Filter and process only physical and main bridge interfaces
        ip -br link show | grep -E "^(en|eth|wl|bond)" | grep -v "veth\|docker" | while read -r line; do
            local interface=$(echo "$line" | awk '{print $1}')
            local speed=""
            local duplex=""
            local ip_addr=$(ip -4 addr show $interface 2>/dev/null | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
            
            echo -e "Interface: ${green}${interface}${reset}"
            if [ ! -z "$ip_addr" ]; then
                echo -e "IP:        ${green}${ip_addr}${reset}"
            fi
            
            if [ -f "/sys/class/net/$interface/speed" ]; then
                speed=$(cat "/sys/class/net/$interface/speed" 2>/dev/null)
                if [ ! -z "$speed" ] && [ "$speed" != "-1" ]; then
                    # Convert speed to Gbps if >= 1000 Mbps
                    if [ $speed -ge 1000 ]; then
                        speed=$(echo "scale=1; $speed/1000" | bc)
                        speed="${speed} Gbps"
                    else
                        speed="${speed} Mbps"
                    fi
                    echo -e "Speed:     ${green}${speed}${reset}"
                fi
            fi
            
            if [ -f "/sys/class/net/$interface/duplex" ]; then
                duplex=$(cat "/sys/class/net/$interface/duplex" 2>/dev/null)
                if [ ! -z "$duplex" ] && [ "$duplex" != "unknown" ]; then
                    echo -e "Duplex:    ${green}${duplex}${reset}"
                fi
            fi
            
            if command -v ethtool >/dev/null 2>&1; then
                local driver=$(ethtool -i "$interface" 2>/dev/null | grep "driver:" | cut -d: -f2- | sed 's/^[ \t]*//')
                if [ ! -z "$driver" ]; then
                    echo -e "Driver:    ${green}${driver}${reset}"
                fi
            fi
            echo ""
        done
    fi

    # Final Results
    echo -e "\n${blue}📊 Benchmark Results Summary${reset}"
    echo -e "CPU Performance:    ${green}$cpu_score ops/s${reset}"
    echo -e "Memory Write:       ${green}$write_speed_display${reset}"
    echo -e "Memory Read:        ${green}$read_speed_display${reset}"
    echo -e "Memory Usage:       ${green}${mem_usage}%${reset}"
    echo -e "Disk Write:         ${green}$write_score MB/s${reset}"
    echo -e "Disk Read:          ${green}$read_score MB/s${reset}"
    echo -e "Sequential IOPS:    ${green}W:${seq_write_iops:-0} R:${seq_read_iops:-0}${reset}"
    echo -e "Random IOPS:        ${green}W:${random_write_iops:-0} R:${random_read_iops:-0}${reset}"
    echo -e "Network Latency:    ${green}${ping_score:-N/A} ms${reset}"
    echo -e "Network Speed:      ${green}${network_score:-0.0} MB/s${reset}\n"

    # Save results to file with timestamp
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    echo "$timestamp,$HOSTNAME,$cpu_score,$write_speed,$read_speed,$mem_usage,$write_score,$read_score,$seq_write_iops,$seq_read_iops,$random_write_iops,$random_read_iops,$ping_score,$network_score" >> ~/.benchmark_history
}
export -f benchmark
export -f progress_bar
export -f format_memory

# Utility Functions

# Extract any type of archive
extract() {
    if [ -z "$1" ]; then
        echo "Usage: extract <file>"
        return 1
    fi
    if [ ! -f "$1" ]; then
        echo "'$1' is not a valid file"
        return 1
    fi
    case "$1" in
        *.tar.bz2)   tar xjf "$1"     ;;
        *.tar.gz)    tar xzf "$1"     ;;
        *.tar.xz)    tar xJf "$1"     ;;
        *.bz2)       bunzip2 "$1"     ;;
        *.rar)       unrar x "$1"     ;;
        *.gz)        gunzip "$1"      ;;
        *.tar)       tar xf "$1"      ;;
        *.tbz2)      tar xjf "$1"     ;;
        *.tgz)       tar xzf "$1"     ;;
        *.zip)       unzip "$1"       ;;
        *.Z)         uncompress "$1"  ;;
        *.7z)        7z x "$1"        ;;
        *)           echo "'$1' cannot be extracted via extract" ;;
    esac
}

# Compress files or directories
compress() {
    if [ -z "$1" ]; then
        echo "Usage: compress <file/directory> [format]"
        echo "Available formats: tar.gz (default), tar.bz2, zip"
        return 1
    fi
    
    local format="${2:-tar.gz}"
    local output
    
    case "$format" in
        tar.gz)
            output="${1%/}.tar.gz"
            tar -czf "$output" "$1"
            ;;
        tar.bz2)
            output="${1%/}.tar.bz2"
            tar -cjf "$output" "$1"
            ;;
        zip)
            output="${1%/}.zip"
            zip -r "$output" "$1"
            ;;
        *)
            echo "Unsupported format. Use: tar.gz, tar.bz2, or zip"
            return 1
            ;;
    esac
    
    echo "Created archive: $output"
}

# Find files with color highlighting
findfile() {
    if [ -z "$1" ]; then
        echo "Usage: findfile <pattern> [path]"
        return 1
    fi
    
    local search_path="${2:-.}"
    find "$search_path" -type f -iname "*$1*" -print0 | while IFS= read -r -d '' file; do
        echo -e "${green}${file}${reset}"
    done
}

# Tree view without external dependencies
tree() {
    if [ -z "$1" ]; then
        echo "Usage: tree [directory] [depth]"
        return 1
    fi
    
    local dir="${1:-.}"
    local indent="${2:-}"
    local max_depth=${3:-4}
    local current_depth=${4:-0}
    
    if [ "$current_depth" -ge "$max_depth" ]; then
        return
    fi
    
    for item in "$dir"/*; do
        if [ -e "$item" ]; then
            local basename="${item##*/}"
            if [ -d "$item" ]; then
                echo -e "${indent}${blue}${basename}${reset}/"
                tree "$item" "$indent│   " "$max_depth" "$((current_depth + 1))"
            else
                echo -e "${indent}${basename}"
            fi
        fi
    done
}

# Disk space analysis
diskspace() {
    echo -e "\n${yellow}Disk Space Analysis${reset}\n"
    
    # Overall disk usage
    echo -e "${bold}Filesystem Usage:${reset}"
    df -h | awk 'NR==1{print} /^\/dev/{print}' | column -t
    echo
    
    # Top 10 largest directories
    echo -e "${bold}Top 10 Largest Directories:${reset}"
    du -hx /* 2>/dev/null | sort -rh | head -n 10
    echo
    
    # Space used by file types
    echo -e "${bold}Space Used by File Types:${reset}"
    find . -type f -exec basename {} \; | grep -o "\.[^.]*$" | sort | uniq -c | sort -rn | head -n 10 | while read count ext; do
        if [ ! -z "$ext" ]; then
            echo "$count files with extension $ext"
        fi
    done
}

# Generate QR code without external dependencies
qrcode() {
    if [ -z "$1" ]; then
        echo "Usage: qrcode <text>"
        return 1
    fi
    
    local text="$1"
    local url="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${text}"
    
    if command -v curl >/dev/null 2>&1; then
        echo "QR Code URL: $url"
        echo "Open this URL in your browser to see the QR code"
    else
        echo "Error: curl is required for this function"
    fi
}

# Check system security
checksec() {
    # Check required packages
    if ! check_requirements "checksec"; then
        return 1
    fi

    echo -e "\n${yellow}Basic Security Check${reset}\n"
    
    # Check SSH configuration
    echo -e "${bold}SSH Configuration:${reset}"
    if [ -f /etc/ssh/sshd_config ]; then
        # Check SSH port
        local ssh_port=$(sudo grep "^Port" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')
        if [ -z "$ssh_port" ]; then
            ssh_port="22"
        fi
        if [ "$ssh_port" = "22" ]; then
            echo -e "SSH Port: ${yellow}$ssh_port${reset} ${yellow}(Recommended: Use non-standard port)${reset}"
        else
            echo -e "SSH Port: ${green}$ssh_port${reset}"
        fi

        # Check root login
        if sudo grep -q "^PermitRootLogin.*no" /etc/ssh/sshd_config 2>/dev/null; then
            echo -e "Root Login: ${green}Disabled${reset}"
        else
            echo -e "Root Login: ${red}Enabled${reset} ${yellow}(Recommended: Disable root login)${reset}"
        fi
        
        # Check password authentication
        if sudo grep -q "^PasswordAuthentication.*no" /etc/ssh/sshd_config 2>/dev/null; then
            echo -e "Password Authentication: ${green}Disabled${reset}"
        else
            echo -e "Password Authentication: ${red}Enabled${reset} ${yellow}(Recommended: Use SSH keys instead)${reset}"
        fi

        # Check public key authentication
        if sudo grep -q "^PubkeyAuthentication.*yes" /etc/ssh/sshd_config 2>/dev/null; then
            echo -e "Public Key Authentication: ${green}Enabled${reset}"
        else
            echo -e "Public Key Authentication: ${red}Disabled${reset} ${yellow}(Recommended: Enable SSH key authentication)${reset}"
        fi

        # Check Protocol version
        if sudo grep -q "^Protocol.*1" /etc/ssh/sshd_config 2>/dev/null; then
            echo -e "SSH Protocol: ${red}Version 1 enabled${reset} ${yellow}(Recommended: Use Protocol 2 only)${reset}"
        else
            echo -e "SSH Protocol: ${green}Version 2${reset}"
        fi

        # Check MaxAuthTries
        local max_auth_tries=$(sudo grep "^MaxAuthTries" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')
        if [ -z "$max_auth_tries" ] || [ "$max_auth_tries" -gt 4 ]; then
            echo -e "Max Auth Tries: ${yellow}${max_auth_tries:-6 (default)}${reset} ${yellow}(Recommended: Set to 4 or less)${reset}"
        else
            echo -e "Max Auth Tries: ${green}$max_auth_tries${reset}"
        fi

        # Check LoginGraceTime
        local login_grace_time=$(sudo grep "^LoginGraceTime" /etc/ssh/sshd_config 2>/dev/null | awk '{print $2}')
        if [ -z "$login_grace_time" ] || [ "$login_grace_time" -gt 60 ]; then
            echo -e "Login Grace Time: ${yellow}${login_grace_time:-120s (default)}${reset} ${yellow}(Recommended: Set to 60 or less)${reset}"
        else
            echo -e "Login Grace Time: ${green}$login_grace_time${reset}"
        fi

        # Check X11 Forwarding
        if sudo grep -q "^X11Forwarding.*yes" /etc/ssh/sshd_config 2>/dev/null; then
            echo -e "X11 Forwarding: ${yellow}Enabled${reset} ${yellow}(Disable if not needed)${reset}"
        else
            echo -e "X11 Forwarding: ${green}Disabled${reset}"
        fi

        # Check AllowTcpForwarding
        if sudo grep -q "^AllowTcpForwarding.*yes" /etc/ssh/sshd_config 2>/dev/null; then
            echo -e "TCP Forwarding: ${yellow}Enabled${reset} ${yellow}(Disable if not needed)${reset}"
        else
            echo -e "TCP Forwarding: ${green}Disabled${reset}"
        fi
    else
        echo "SSH server not installed"
    fi
    
    # Check firewall status
    echo -e "\n${bold}Firewall Status:${reset}"
    if command -v ufw >/dev/null 2>&1; then
        if sudo ufw status | grep -q "Status: active"; then
            echo -e "${green}UFW is active${reset}"
            echo -e "\n${bold}Enabled UFW Rules:${reset}"
            sudo ufw status numbered | grep -v "Status:" | grep "[0-9]"
        else
            echo -e "${red}UFW is inactive${reset} ${yellow}(Recommended: Enable and configure UFW)${reset}"
        fi
    elif command -v firewall-cmd >/dev/null 2>&1; then
        if sudo firewall-cmd --state | grep -q "running"; then
            echo -e "${green}FirewallD is active${reset}"
            echo -e "\n${bold}Enabled FirewallD Rules:${reset}"
            sudo firewall-cmd --list-all
        else
            echo -e "${red}FirewallD is inactive${reset} ${yellow}(Recommended: Enable and configure FirewallD)${reset}"
        fi
    else
        echo -e "${red}No firewall detected${reset} ${yellow}(Recommended: Install and configure a firewall)${reset}"
    fi
    
    # Check for running services
    echo -e "\n${bold}Exposed Services:${reset}"
    echo "Port     Protocol  State   Service"
    echo "----------------------------------------"
    if command -v ss >/dev/null 2>&1; then
        ss -tuln | grep LISTEN | awk '{
            split($5, a, ":")
            port = a[length(a)]
            proto = $1
            printf "%-8s %-9s %-7s ", port, proto, "LISTEN"
            system("grep -w " port " /etc/services 2>/dev/null | head -1 | awk \"{print \\$1}\"")
        }' | sort -n | column -t
    else
        netstat -tuln | grep LISTEN | awk '{
            split($4, a, ":")
            port = a[length(a)]
            proto = $1
            printf "%-8s %-9s %-7s ", port, proto, "LISTEN"
            system("grep -w " port " /etc/services 2>/dev/null | head -1 | awk \"{print \\$1}\"")
        }' | sort -n | column -t
    fi
    
    # Check system updates
    echo -e "\n${bold}System Updates:${reset}"
    local updates_count=0
    local security_updates=0
    if command -v apt >/dev/null 2>&1; then
        updates_count=$(sudo apt list --upgradable 2>/dev/null | grep -v "Listing..." | wc -l)
        if [ $updates_count -gt 0 ]; then
            echo -e "${red}$updates_count package(s) can be upgraded:${reset}"
            sudo apt list --upgradable 2>/dev/null | grep -v "Listing..."
        else
            echo -e "${green}System is up to date${reset}"
        fi
    elif command -v yum >/dev/null 2>&1; then
        updates_count=$(sudo yum check-update --quiet | grep -v "^$" | wc -l)
        if [ $updates_count -gt 0 ]; then
            echo -e "${red}$updates_count package(s) can be upgraded:${reset}"
            sudo yum check-update --quiet
        else
            echo -e "${green}System is up to date${reset}"
        fi
    fi
    
    # Check for failed login attempts
    echo -e "\n${bold}Failed Login Attempts (last 24h):${reset}"
    if [ -f /var/log/auth.log ]; then
        local failed_count=$(sudo grep "Failed password" /var/log/auth.log 2>/dev/null | wc -l)
        echo "Total failed attempts: $failed_count"
        if [ $failed_count -gt 0 ]; then
            echo -e "\nLast 5 failed attempts:"
            sudo grep "Failed password" /var/log/auth.log 2>/dev/null | tail -n 5
        fi
    elif [ -f /var/log/secure ]; then
        local failed_count=$(sudo grep "Failed password" /var/log/secure 2>/dev/null | wc -l)
        echo "Total failed attempts: $failed_count"
        if [ $failed_count -gt 0 ]; then
            echo -e "\nLast 5 failed attempts:"
            sudo grep "Failed password" /var/log/secure 2>/dev/null | tail -n 5
        fi
    fi
    
    # Check system logs for errors
    echo -e "\n${bold}Recent System Errors:${reset}"
    if [ -f /var/log/syslog ]; then
        echo "Last 5 system errors from syslog:"
        sudo grep -i "error\|failed\|warning" /var/log/syslog 2>/dev/null | tail -n 5
    elif [ -f /var/log/messages ]; then
        echo "Last 5 system errors from messages:"
        sudo grep -i "error\|failed\|warning" /var/log/messages 2>/dev/null | tail -n 5
    fi
    
    # Security Recommendations
    echo -e "\n${bold}Security Recommendations:${reset}"
    local recommendations=()
    
    # SSH Recommendations
    if [ -f /etc/ssh/sshd_config ]; then
        if sudo grep -q "^PermitRootLogin.*yes" /etc/ssh/sshd_config 2>/dev/null; then
            recommendations+=("Disable SSH root login (edit /etc/ssh/sshd_config)")
        fi
        if sudo grep -q "^PasswordAuthentication.*yes" /etc/ssh/sshd_config 2>/dev/null; then
            recommendations+=("Disable SSH password authentication and use keys instead (edit /etc/ssh/sshd_config)")
        fi
        if ! sudo grep -q "^PubkeyAuthentication.*yes" /etc/ssh/sshd_config 2>/dev/null; then
            recommendations+=("Enable SSH key authentication (edit /etc/ssh/sshd_config)")
        fi
    fi
    
    # Firewall Recommendations
    if ! command -v ufw >/dev/null 2>&1 && ! command -v firewall-cmd >/dev/null 2>&1; then
        recommendations+=("Install and configure a firewall (UFW or FirewallD)")
    elif command -v ufw >/dev/null 2>&1; then
        if ! sudo ufw status | grep -q "Status: active"; then
            recommendations+=("Enable UFW firewall (sudo ufw enable)")
        fi
    elif command -v firewall-cmd >/dev/null 2>&1; then
        if ! sudo firewall-cmd --state | grep -q "running"; then
            recommendations+=("Enable FirewallD (sudo systemctl start firewalld)")
        fi
    fi
    
    # Security Tools Recommendations
    if ! command -v fail2ban-client >/dev/null 2>&1; then
        recommendations+=("Install Fail2ban to protect against brute force attacks")
    fi
    if ! command -v chkrootkit >/dev/null 2>&1 && ! command -v rkhunter >/dev/null 2>&1; then
        recommendations+=("Install a rootkit scanner (chkrootkit or rkhunter)")
    fi
    if ! command -v auditd >/dev/null 2>&1; then
        recommendations+=("Install auditd for system auditing")
    fi
    
    # System Updates
    if command -v apt >/dev/null 2>&1; then
        updates_count=$(sudo apt list --upgradable 2>/dev/null | grep -v "Listing..." | wc -l)
        if [ $updates_count -gt 0 ]; then
            recommendations+=("Update system packages (sudo apt update && sudo apt upgrade)")
        fi
    elif command -v yum >/dev/null 2>&1; then
        updates_count=$(sudo yum check-update --quiet | grep -v "^$" | wc -l)
        if [ $updates_count -gt 0 ]; then
            recommendations+=("Update system packages (sudo yum update)")
        fi
    fi
    
    # Password Policies
    if [ -f /etc/login.defs ]; then
        if ! grep -q "^PASS_MAX_DAYS.*90" /etc/login.defs; then
            recommendations+=("Set password expiration to 90 days maximum")
        fi
        if ! grep -q "^PASS_MIN_LEN.*12" /etc/login.defs; then
            recommendations+=("Set minimum password length to 12 characters")
        fi
    fi
    
    # SELinux/AppArmor
    if command -v sestatus >/dev/null 2>&1; then
        if ! sestatus | grep -q "SELinux status:.*enabled"; then
            recommendations+=("Enable SELinux for enhanced security")
        fi
    elif command -v apparmor_status >/dev/null 2>&1; then
        if ! apparmor_status | grep -q "apparmor module is loaded"; then
            recommendations+=("Enable AppArmor for enhanced security")
        fi
    fi
    
    # Add to recommendations array
    if [ "$ssh_port" = "22" ]; then
        recommendations+=("Change SSH port from default 22 to a non-standard port")
    fi
    if sudo grep -q "^Protocol.*1" /etc/ssh/sshd_config 2>/dev/null; then
        recommendations+=("Disable SSH Protocol 1 (use Protocol 2 only)")
    fi
    if [ -z "$max_auth_tries" ] || [ "$max_auth_tries" -gt 4 ]; then
        recommendations+=("Reduce MaxAuthTries to 4 or less in SSH config")
    fi
    if [ -z "$login_grace_time" ] || [ "$login_grace_time" -gt 60 ]; then
        recommendations+=("Reduce LoginGraceTime to 60 seconds or less in SSH config")
    fi
    if sudo grep -q "^X11Forwarding.*yes" /etc/ssh/sshd_config 2>/dev/null; then
        recommendations+=("Disable X11 Forwarding if not needed")
    fi
    if sudo grep -q "^AllowTcpForwarding.*yes" /etc/ssh/sshd_config 2>/dev/null; then
        recommendations+=("Disable TCP Forwarding if not needed")
    fi
    
    # Check for world-writable files in /etc
    local world_writable=$(sudo find /etc -type f -perm -002 2>/dev/null | wc -l)
    if [ "$world_writable" -gt 0 ]; then
        echo -e "${red}Found $world_writable world-writable files in /etc${reset}"
        recommendations+=("Remove world-writable permissions from files in /etc")
    else
        echo -e "${green}No world-writable files found in /etc${reset}"
    fi

    # Display recommendations
    if [ ${#recommendations[@]} -gt 0 ]; then
        echo -e "${yellow}Recommended actions:${reset}"
        for i in "${!recommendations[@]}"; do
            echo -e "$(($i + 1)). ${recommendations[$i]}"
        done
    else
        echo -e "${green}No immediate security concerns found${reset}"
    fi
    
    echo -e "\n${bold}Note:${reset} These recommendations are general security best practices."
    echo "Some may not apply to your specific use case or security requirements."
    echo "Always evaluate security changes in the context of your system's needs."
}

# Watch logs in real-time with color highlighting
logwatch() {
    # Check required packages
    if ! check_requirements "logwatch"; then
        return 1
    fi

    local log_file="/var/log/syslog"
    if [ ! -f "$log_file" ]; then
        log_file="/var/log/messages"
    fi
    
    if [ ! -f "$log_file" ]; then
        echo "No system log file found"
        return 1
    fi
    
    echo -e "Watching ${yellow}$log_file${reset} (Press Ctrl+C to stop)"
    sudo tail -f "$log_file" 2>/dev/null | while read -r line; do
        case "$line" in
            *ERROR*|*error*|*fail*|*FAIL*)
                echo -e "${red}$line${reset}"
                ;;
            *WARN*|*warn*|*WARNING*|*warning*)
                echo -e "${yellow}$line${reset}"
                ;;
            *INFO*|*info*)
                echo -e "${green}$line${reset}"
                ;;
            *)
                echo "$line"
                ;;
        esac
    done
}

# Cleanup helper function for webshare
webshare_cleanup() {
    local cleanup_port="$1"
    if [ -z "$cleanup_port" ]; then
        echo "Usage: webshare_cleanup <port>"
        return 1
    fi

    local cleanup_lock="/tmp/webshare_${cleanup_port}.lock"
    local cleanup_pid="/tmp/webshare_${cleanup_port}.pid"

    echo -e "${yellow}Forcing cleanup for port $cleanup_port...${reset}"

    # Kill any Python process using this port
    local pid=$(netstat -tlpn 2>/dev/null | grep ":${cleanup_port}" | grep "python" | awk '{print $7}' | cut -d'/' -f1)
    if [ ! -z "$pid" ]; then
        echo "Killing process $pid..."
        kill -9 "$pid" 2>/dev/null
    fi

    # Remove firewall rules
    if command -v ufw >/dev/null 2>&1; then
        echo "Removing UFW rules..."
        sudo ufw delete allow $cleanup_port/tcp >/dev/null 2>&1
        sudo ufw delete allow $cleanup_port/tcp >/dev/null 2>&1 # Delete IPv6 rule
    elif command -v firewall-cmd >/dev/null 2>&1; then
        echo "Removing FirewallD rule..."
        sudo firewall-cmd --remove-port=$cleanup_port/tcp >/dev/null 2>&1
    fi

    # Remove lock and pid files
    rm -f "$cleanup_lock" "$cleanup_pid"

    echo -e "${green}Cleanup complete for port $cleanup_port${reset}"
}
export -f webshare_cleanup

# Function to share current directory via HTTP
webshare() {
    local port="${1:-8000}"  # Use port 8000 if no port specified
    local pid_file="/tmp/webshare_${port}.pid"
    local lock_file="/tmp/webshare_${port}.lock"

    # Check if port is already in use
    if netstat -tuln | grep -q ":${port}"; then
        echo -e "${red}Port ${port} is already in use${reset}"
        return 1
    fi

    # Check if there's a stale lock file
    if [ -f "$lock_file" ]; then
        echo -e "${yellow}Found stale lock file. Cleaning up...${reset}"
        webshare_cleanup $port
    fi

    # Check requirements
    if ! check_requirements "webshare"; then
        return 1
    fi

    # Create lock file
    touch "$lock_file"

    # Configure firewall
    if command -v ufw >/dev/null 2>&1; then
        echo -e "${yellow}Configuring UFW firewall...${reset}"
        sudo ufw allow $port/tcp >/dev/null 2>&1
    elif command -v firewall-cmd >/dev/null 2>&1; then
        echo -e "${yellow}Configuring FirewallD...${reset}"
        sudo firewall-cmd --add-port=$port/tcp >/dev/null 2>&1
    fi

    # Function to clean up on exit
    cleanup() {
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file")
            if [ -n "$pid" ]; then
                kill $pid 2>/dev/null
            fi
            rm -f "$pid_file"
        fi

        # Remove firewall rules
        if command -v ufw >/dev/null 2>&1; then
            echo -e "${yellow}Removing UFW rules...${reset}"
            sudo ufw delete allow $port/tcp >/dev/null 2>&1
        elif command -v firewall-cmd >/dev/null 2>&1; then
            echo -e "${yellow}Removing FirewallD rules...${reset}"
            sudo firewall-cmd --remove-port=$port/tcp >/dev/null 2>&1
        fi

        # Remove lock file
        rm -f "$lock_file"
        echo -e "${green}Server stopped and cleaned up${reset}"
    }

    # Set up trap for cleanup
    trap cleanup EXIT INT TERM

    # Start the Python server
    python3 /tmp/webshare.py $port &
    server_pid=$!
    echo $server_pid > "$pid_file"

    # Wait for the server process but allow interruption
    wait $server_pid || { cleanup; return 0; }
}

export -f webshare

# Function to read logs with colors
logs() {
    local log_file="$1"
    local default_log="/var/log/syslog"  # Default log file

    # If no argument is provided, show available log files
    if [ -z "$log_file" ]; then
        echo -e "${yellow}Available log files:${reset}"
        ls -1 /var/log/ | grep -E "\.log$|syslog" | while read -r file; do
            if [ -r "/var/log/$file" ]; then
                echo -e "${green}$file${reset}"
            else
                echo -e "${red}$file${reset} (no read permission)"
            fi
        done
        return
    fi

    # If the file doesn't exist in current directory, check in /var/log/
    if [ ! -f "$log_file" ]; then
        if [ -f "/var/log/$log_file" ]; then
            log_file="/var/log/$log_file"
        elif [ ! -f "$log_file" ] && [ "$log_file" != "-f" ]; then
            echo -e "${red}Log file not found: $log_file${reset}"
            return 1
        fi
    fi

    # Check if we want to follow the log file
    if [ "$log_file" = "-f" ]; then
        tail -f "$default_log" | ccze -A
    elif [ "$2" = "-f" ]; then
        tail -f "$log_file" | ccze -A
    else
        # If the file is compressed, use zcat
        if [[ "$log_file" =~ \.gz$ ]]; then
            zcat "$log_file" | ccze -A | less -R
        else
            cat "$log_file" | ccze -A | less -R
        fi
    fi
}
# Function to display all IP addresses nicely formatted
ips() {
    echo -e "\n${bold}Information IP de la machine :${reset}\n"
    
    # External IP with timeout
    echo -e "${yellow}IP Externe :${reset}"
    external_ip=$(curl -s --connect-timeout 3 --max-time 3 ifconfig.me 2>/dev/null)
    if [ $? -eq 0 ] && [ -n "$external_ip" ]; then
        echo -e "  ${blue}$external_ip${reset}\n"
    else
        echo -e "  ${red}Non disponible (timeout)${reset}\n"
    fi
    
    # Local IPs
    echo -e "${yellow}IPs Locales :${reset}"
    if command -v ip >/dev/null 2>&1; then
        # Using ip command (modern systems)
        ip -o addr show | grep 'inet ' | while read -r line; do
            interface=$(echo $line | awk '{print $2}')
            ip_addr=$(echo $line | awk '{print $4}')
            
            # Get gateway for this interface
            gateway=$(ip route show dev $interface | grep -E '^default' | awk '{print $3}' 2>/dev/null)
            if [ -n "$gateway" ]; then
                echo -e "  ${green}$interface${reset}: ${blue}$ip_addr${reset} (${white}$gateway${reset})"
            else
                echo -e "  ${green}$interface${reset}: ${blue}$ip_addr${reset}"
            fi
        done
    else
        # Fallback to ifconfig
        ifconfig | grep -E "inet |inet addr:" | grep -v "127.0.0.1" | while read -r line; do
            interface=$(echo $line | awk '{print $1}')
            ip_addr=$(echo $line | grep -oE "inet ([0-9]{1,3}\.){3}[0-9]{1,3}" | cut -d' ' -f2)
            
            # Get gateway for this interface
            gateway=$(route -n | grep "^0.0.0.0" | grep $interface | awk '{print $2}' 2>/dev/null)
            if [ -n "$gateway" ]; then
                echo -e "  ${green}$interface${reset}: ${blue}$ip_addr${reset} (${white}$gateway${reset})"
            else
                echo -e "  ${green}$interface${reset}: ${blue}$ip_addr${reset}"
            fi
        done
    fi
    
    # IPv6 addresses
    echo -e "\n${yellow}IPs IPv6 :${reset}"
    if command -v ip >/dev/null 2>&1; then
        ip -o addr show | grep 'inet6 ' | while read -r line; do
            interface=$(echo $line | awk '{print $2}')
            ipv6_addr=$(echo $line | awk '{print $4}')
            
            # Get IPv6 gateway for this interface
            gateway6=$(ip -6 route show dev $interface | grep -E '^default' | awk '{print $3}' 2>/dev/null)
            if [ -n "$gateway6" ]; then
                echo -e "  ${green}$interface${reset}: ${purple}$ipv6_addr${reset} (${white}$gateway6${reset})"
            else
                echo -e "  ${green}$interface${reset}: ${purple}$ipv6_addr${reset}"
            fi
        done
    else
        ifconfig | grep -E "inet6 |inet6 addr:" | grep -v "::1" | while read -r line; do
            interface=$(echo $line | awk '{print $1}')
            ipv6_addr=$(echo $line | grep -oE "inet6 [0-9a-fA-F:]{3,}" | cut -d' ' -f2)
            
            # Get IPv6 gateway for this interface
            gateway6=$(route -A inet6 | grep "^default" | grep $interface | awk '{print $2}' 2>/dev/null)
            if [ -n "$gateway6" ]; then
                echo -e "  ${green}$interface${reset}: ${purple}$ipv6_addr${reset} (${white}$gateway6${reset})"
            else
                echo -e "  ${green}$interface${reset}: ${purple}$ipv6_addr${reset}"
            fi
        done
    fi

    # DNS Information
    echo -e "\n${yellow}Serveurs DNS :${reset}"
    if [ -f /etc/resolv.conf ]; then
        # Primary DNS servers from resolv.conf
        while read -r line; do
            if [[ $line =~ ^nameserver ]]; then
                dns_server=$(echo $line | awk '{print $2}')
                # Test if it's an IPv6 address
                if [[ $dns_server =~ ":" ]]; then
                    echo -e "  ${purple}$dns_server${reset}"
                else
                    echo -e "  ${blue}$dns_server${reset}"
                fi
            fi
        done < /etc/resolv.conf

        # Search domains
        search_domains=$(grep "^search" /etc/resolv.conf | cut -d' ' -f2-)
        if [ -n "$search_domains" ]; then
            echo -e "\n${yellow}Domaines de recherche :${reset}"
            echo -e "  ${cyan}$search_domains${reset}"
        fi
    else
        echo -e "  ${red}Fichier /etc/resolv.conf non trouvé${reset}"
    fi

    # Try to get systemd-resolved status if available
    if command -v resolvectl &>/dev/null; then
        echo -e "\n${yellow}Configuration DNS détaillée (systemd-resolved) :${reset}"
        resolvectl status 2>/dev/null | while read -r line; do
            if [[ $line =~ ^Global|^Link|^DNS|^Current|^DNSSEC|^DNS\ Domain ]]; then
                echo -e "  ${grey}$line${reset}"
            fi
        done
    fi
    
    echo ""
}
export -f ips
